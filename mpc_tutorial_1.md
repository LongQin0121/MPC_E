
#### https://towardsdatascience.com/model-predictive-control-basics/
# Model Predictive Control Basics
#### A hands-on tutorial with Python and CasADi
Willem Esterhuizen

## 升级版公式

### 原始系统 + 显式输出
```python
# === 状态演化（如何变化）===
x_{k+1} = A x_k + B u_k

其中：x_k = [位置_k, 速度_k]^T ∈ R^2

# === 输出方程（控制什么）===  
y_k = C x_k + D u_k

其中：C = [1, 0]  # 只输出位置
     D = [0]      # 输出不直接依赖当前控制
     y_k ∈ R^1   # 1维输出：位置

# === 控制（用什么手段）===
u_k ∈ R^1  # 1维控制：力

```

### 升级版优化问题
```python
OCP_with_output(x̄):

minimize: ∑_{k=0}^{K-1} [y_k^T Q_y y_k + x_k^T Q_x x_k + u_k^T R u_k] + y_K^T Q_{yK} y_K

subject to:
    x_{k+1} = A x_k + B u_k,     k ∈ [0:K-1]  # 状态演化约束
    y_k = C x_k + D u_k,         k ∈ [0:K]    # 输出定义约束  
    x_0 = x̄,                                  # 初始条件
    y_k ∈ [-1, 1],              k ∈ [0:K]    # 输出约束（位置限制）
    u_k ∈ [-1, 1],              k ∈ [0:K-1]  # 控制约束
```

### 关键升级点总结

#### 1. 显式三层结构

```python
# === 三者明确分离 ===
状态 x: [位置, 速度]      # 系统内部演化变量
输出 y: [位置]           # 我们真正关心控制的量  
控制 u: [力]            # 我们的控制手段

# === 数学关系 ===
x_{k+1} = A x_k + B u_k  # 状态演化（如何变化）
y_k = C x_k + D u_k      # 输出定义（控制什么）  
u_k 通过改变 x_k 来影响 y_k  # 控制逻辑（用什么手段）

```

#### 2. 输出方程设计
```python
C = [1, 0]  # 只输出位置，不输出速度
D = [0]     # 输出不直接依赖当前控制

# 这意味着：我们主要关心位置控制，速度是辅助状态

```

#### 3. 分层成本函数
```python

# 原版：J = x^T Q x + u^T R u
# 升级：J = y^T Q_y y + x^T Q_x x + u^T R u
#           ↑         ↑         ↑
#        输出成本   状态成本   控制成本
#       (主要目标) (辅助调节) (平滑控制)
```

#### 4. 约束直接施加在输出上
```
# 原版：x[0] ∈ [-1,1]  (直接约束状态)
# 升级：y ∈ [-1,1]     (约束输出，更有物理意义)

```

####  运行效果示例
```
=== MPC with Explicit Output Equation ===
Initial output: y=0.50m (position)
Target: drive output (position) to 0

Step  0: output=0.500m, state=[0.500, 0.500], control=-1.000N
Step  1: output=0.549m, state=[0.549, 0.400], control=-1.000N  
Step  2: output=0.589m, state=[0.589, 0.300], control=-1.000N
...
Step 20: output=0.051m, state=[0.051, -0.123], control=0.334N
Step 30: output=-0.008m, state=[-0.008, 0.045], control=-0.127N

✅ Converged! Final output: 0.0003m
```
关键洞察：这个升级版清晰地展示了MPC三要素的分工：

状态：描述系统如何演化
输出：定义我们真正的控制目标
控制：提供影响演化的手段

通过输出方程，我们实现了"控制什么"与"如何演化"的优雅分离！🎯


---
#### 解释为什么要"拆分"成本函数：
数学上的等价性
在这个简单例子中，两种表达其实可以等价：
```python
# === 原版 ===
J = x^T Q x + u^T R u
# 其中 x = [位置, 速度], Q = [[q1, 0], [0, q2]]
# 展开：J = q1*位置² + q2*速度² + R*u²

# === 升级版 ===  
J = y^T Q_y y + x^T Q_x x + u^T R u
# 其中 y = 位置, Q_y = [10], Q_x = [[0, 0], [0, 1]]
# 展开：J = 10*位置² + 0*位置² + 1*速度² + R*u²
#      = 10*位置² + 1*速度² + R*u²

# 如果设置：Q = [[10, 0], [0, 1]]，两者完全相同！

```

#### 那为什么要分离？核心原因：
1. 概念清晰度
```python
# === 原版：混在一起 ===
Q = [[10, 0],     # 这个10是什么意思？位置权重？输出权重？
     [0,  1]]     # 这个1是什么意思？速度权重？

# 工程师看到Q矩阵，需要思考："哪些是我真正关心的控制目标？"

# === 升级版：意图明确 ===
Q_y = [10]        # 明确：输出(位置)的控制目标权重
Q_x = [[0, 0],    # 明确：状态中非输出部分的调节权重  
       [0, 1]]    # (这里只对速度有轻微调节)
R = [1]           # 明确：控制成本

# 工程师一看就知道：主要目标是控制位置，略微调节速度


```
2. 设计灵活性

```python
# === 不同设计需求的例子 ===

# 需求A：只关心最终位置，完全不管速度
Q_y = [100]       # 强烈关心位置
Q_x = [[0, 0],    # 完全不管速度
       [0, 0]]    

# 需求B：关心位置，但速度不能太激烈
Q_y = [50]        # 关心位置
Q_x = [[0, 0],    # 同时约束速度  
       [0, 10]]   

# 需求C：既要位置准确，又要速度平滑
Q_y = [100]       # 主要目标：位置
Q_x = [[0, 0],    # 辅助目标：速度平滑
       [0, 20]]   

# 用原版的Q矩阵很难表达这种层次化的设计意图
```

3. 可扩展性（当y ≠ x时）
```python
# === 复杂输出的例子 ===
# 假设我们控制的是"距离目标点的距离"：
# x = [位置x, 位置y, 速度x, 速度y]  # 4个状态
# y = sqrt((位置x-目标x)² + (位置y-目标y)²)  # 1个输出

# 原版方法：无法直接表达
# J = x^T Q x + u^T R u  # Q是4×4矩阵，但我关心的是距离，不是状态

# 升级版方法：自然表达
# J = y^T Q_y y + x^T Q_x x + u^T R u
# 其中 y = 距离函数, Q_y = [100]  # 直接优化我关心的距离！

```

### 实际代码对比
原版权重设计过程
```python
# 工程师的困惑过程：
print("我想让位置控制精度高，速度稍微平滑...")
print("那么Q矩阵应该设成什么？")

Q_option1 = [[100, 0], [0, 1]]   # 位置权重高？
Q_option2 = [[50, 0], [0, 10]]   # 还是这样？
Q_option3 = [[10, 0], [0, 0.1]]  # 或者这样？

print("哪个Q能表达我的控制意图？🤔")
```

升级版权重设计过程
```python
# 工程师的清晰过程：
print("我的主要控制目标：位置精度")
Q_y = [100]  # 输出权重：位置控制精度

print("我的辅助调节目标：速度不要太激烈")  
Q_x = [[0, 0], [0, 5]]  # 状态权重：速度平滑

print("我的控制平滑需求：")
R = [1]  # 控制权重：力的平滑性

print("意图清晰！✅")


```


实际权重调试对比

```python
# === 调试场景：控制太激进 ===

# 原版调试：
print("位置控制太激进，需要降低位置权重...")
Q = [[50, 0], [0, 1]]  # 从100改到50
print("但这样会不会影响精度？🤔")

# 升级版调试：
print("位置控制太激进，增加速度约束...")
Q_y = [100]  # 位置权重保持高精度
Q_x = [[0, 0], [0, 20]]  # 增加速度权重，抑制激进行为
print("精度和平滑性分别调节！✅")

```

#### 总结
分离成本函数的价值：

数学等价但概念不同：y^T Q_y y + x^T Q_x x = x^T Q x（特殊情况下）
设计意图清晰：明确区分"控制目标"vs"状态调节"
参数调试方便：分别调节输出精度和状态平滑性
未来扩展友好：当输出复杂时（y ≠ x），分离的优势明显

关键洞察：不是为了数学上的必要性，而是为了工程设计的清晰性！🎯
简单情况下看起来"多余"，但它为复杂系统设计提供了清晰的框架！